#pragma config(Sensor, dgtl8,  ,               sensorSONAR_inch)
#pragma config(Motor,  port2,            ,             tmotorServoContinuousRotation, openLoop, reversed)
#pragma config(Motor,  port3,            ,             tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port4,            ,             tmotorServoContinuousRotation, openLoop)
#pragma platform(VEX)
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// config motors
int leftWheel = port2;
int rightWheel = port3;
int arm = port4;

// config motor values
int rightWheelValue = 0;
int leftWheelValue = 0;
int forwardDirection = -1;

// config global sensor values
int distanceFrom = SensorValue[dgtl8];

// config global decision values
int macroSequence = 0;

// config global toggle values
bool btn8_toggle = false;
bool btn7_toggle = false;
bool autonomous_toggle = false;

// User Control
// -------------------------------------------------

void manualOneStickDrive(int direction)
{
	// ensure direction is value of 1 with given sign
	direction = direction / abs(direction);

	//get velocity (forward and backward)
	rightWheelValue = vexRT[Ch2] * direction;
	leftWheelValue = vexRT[Ch2] * direction;
	//adjust velocity to turn (left and right)
	rightWheelValue -= vexRT[Ch1];
	leftWheelValue += vexRT[Ch1];
	// update motor values
	motor[rightWheel] = rightWheelValue;
	motor[leftWheel] = leftWheelValue;
}

void manualTwoStickDrive(int direction)
{
	// ensure direction is value of 1 with given sign
	direction = direction / abs(direction);
	leftWheelValue = direction * vexRT[Ch3];
	rightWheelValue = direction * vexRT[Ch2];
	// update motor values
	motor[rightWheel] = rightWheelValue;
	motor[leftWheel] = leftWheelValue;
}

void manualAccelerometerDrive (int direction)
{
	// ensure direction is value of 1 with given sign
	direction = direction / abs(direction);
	//get velocity (forward and backward)
	rightWheelValue = -vexRT[AccelY] * direction;
	leftWheelValue = -vexRT[AccelY] * direction;
	//adjust velocity to turn (left and right)
	rightWheelValue -= vexRT[AccelX];
	leftWheelValue += vexRT[AccelX];
	// update motor values
	motor[rightWheel] = rightWheelValue;
	motor[leftWheel] = leftWheelValue;
}

void moveClaw()
{
	if((vexRT[Btn5U] == 1 && vexRT[Btn5D] == 1) || (vexRT[Btn5U] == 0 && vexRT[Btn5D] == 0))
	{
		motor[arm] = 0;
	}
	else if(vexRT[Btn5D] == 1)
	{
		motor[arm] = 127;
	}
	else if(vexRT[Btn5U] == 1)
	{
		motor[arm] = -127;
	}
}

void userDrive()
{
	// manage control modes with sustained press
	if(vexRT[Btn6D] == 1)
	{
		manualTwoStickDrive(forwardDirection);
	}
	else if (vexRT[Btn6U] == 1)
	{
		manualAccelerometerDrive(forwardDirection);
	}
	else
	{
		manualOneStickDrive(forwardDirection);
	}
}

void manualOneStickSteer()
{
	// let user steer
	rightWheelValue -= vexRT[Ch1];
	leftWheelValue += vexRT[Ch1];
}

// Data Input
// --------------------------------------------------

void updateSensorValues()
{
	// update sensor values
	distanceFrom = SensorValue[dgtl8];
}


// Autonomous mode
// --------------------------------------------------

/*
Some notes:
	robot max speed is 12/5 ft/s (1 trial - quick test)
	robot max rotational speed is 5/4 rotations per second (1 trial - quick test)
*/

void turn(float radians)
{
	motor[leftWheel] = -127 * radians / abs(radians);
	motor[rightWheel] = 127 * radians / abs(radians);
	wait1Msec(1000 * 1.5 * abs(radians) / (2 * PI));
	motor[leftWheel] = 0;
	motor[rightWheel] = 0;
}

void travelForward(float feet)
{
	motor[leftWheel] = 127 * feet / abs(feet);
	motor[rightWheel] = 127 * feet / abs(feet);
	wait1Msec(1000 * (2.4 / abs(feet)));
	motor[leftWheel] = 0;
	motor[rightWheel] = 0;
}

// Macros sequence for autonomous starting from the left square, facing goal (robot should face the wall)
void macroSequence1()
{
	turn(3 * PI / 4);

	motor[rightWheel] = 127;
	motor[leftWheel] = 127;
	motor[arm] = 20;

	updateSensorValues();
	while(distanceFrom > 5)
	{
		updateSensorValues();
	}

	motor[rightWheel] = 0;
	motor[leftWheel] = 0;

	motor[arm] = 127;
	wait1Msec(1500);
	motor[arm] = 0;
}

// Macro sequence for autonomous starting from right square, facing goal (robot should face playing field)
void macroSequence2()
{
	turn(PI / 4);

	motor[rightWheel] = 127;
	motor[leftWheel] = 127;
	motor[arm] = 20;

	updateSensorValues();
	while(distanceFrom > 5)
	{
		updateSensorValues();
	}

	motor[rightWheel] = 0;
	motor[leftWheel] = 0;

	motor[arm] = 127;
	wait1Msec(1500);
	motor[arm] = 0;
}

void autonomousMission()
{
	autonomous_toggle = false;

	if(macroSequence == 0)
	{
		// determine sequence of moves
		if(distanceFrom < 20)
		{
			macroSequence = 1;
		}
		else
		{
			macroSequence = 2;
		}

		autonomous_toggle = true;
	}
	else if (macroSequence == 1)
	{
		macroSequence1();
		// reset macro sequence
		macroSequence = 0;
	}
	else
	{
		macroSequence2();
		// reset macro sequence
		macroSequence = 0;
	}
}

// Main
// --------------------------------------------

void pre_autonomous()
{
}

task autonomous()
{
	autonomousMission();
}

task main()
{

	while(true)
	{
		// get user input
		userDrive();
		moveClaw();

		// toggle forward direction
		if(vexRT[Btn8D] == 1)
		{
			if(btn8_toggle == false)
			{
				forwardDirection *= -1;
			}
			btn8_toggle = true;
		}
		else
		{
			btn8_toggle = false;
		}

		updateSensorValues();
	}
}
