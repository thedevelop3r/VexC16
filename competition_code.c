#pragma config(Sensor, dgtl8,  ,               sensorSONAR_inch)
#pragma config(Motor,  port2,            ,             tmotorServoContinuousRotation, openLoop, reversed)
#pragma config(Motor,  port3,            ,             tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port4,            ,             tmotorServoContinuousRotation, openLoop)
#pragma platform(VEX)
#include "Vex_Competition_Includes.c"
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// config motors
int leftWheel = port2;
int rightWheel = port3;
int arm = port4;

// config motor values
int rightWheelValue = 0;
int leftWheelValue = 0;
int forwardDirection = 1;

// config global sensor values
int distanceFrom = SensorValue[dgtl8];

// config global decision values
int macroSequence = 0;

// config global toggle values
bool btn8_toggle = false;
bool btn7_toggle = false;
bool autonomous_toggle = false;

// User Control
// -------------------------------------------------

void manualOneStickDrive(int direction)
{
	// ensure direction is value of 1 with given sign
	direction = direction / abs(direction);

	//get velocity (forward and backward)
	rightWheelValue = vexRT[Ch2] * direction;
	leftWheelValue = vexRT[Ch2] * direction;
	//adjust velocity to turn (left and right)
	rightWheelValue -= vexRT[Ch1];
	leftWheelValue += vexRT[Ch1];
	// update motor values
	motor[rightWheel] = rightWheelValue;
	motor[leftWheel] = leftWheelValue;
}

void manualTwoStickDrive(int direction)
{
	// ensure direction is value of 1 with given sign
	direction = direction / abs(direction);
	leftWheelValue = direction * vexRT[Ch3];
	rightWheelValue = direction * vexRT[Ch2];
	// update motor values
	motor[rightWheel] = rightWheelValue;
	motor[leftWheel] = leftWheelValue;
}

void manualAccelerometerDrive (int direction)
{
	// ensure direction is value of 1 with given sign
	direction = direction / abs(direction);
	//get velocity (forward and backward)
	rightWheelValue = -vexRT[AccelY] * direction;
	leftWheelValue = -vexRT[AccelY] * direction;
	//adjust velocity to turn (left and right)
	rightWheelValue -= vexRT[AccelX];
	leftWheelValue += vexRT[AccelX];
	// update motor values
	motor[rightWheel] = rightWheelValue;
	motor[leftWheel] = leftWheelValue;
}

void moveClaw()
{
	if((vexRT[Btn5U] == 1 && vexRT[Btn5D] == 1) || (vexRT[Btn5U] == 0 && vexRT[Btn5D] == 0))
	{
		motor[arm] = 0;
	}
	else if(vexRT[Btn5D] == 1)
	{
		motor[arm] = 127;
	}
	else if(vexRT[Btn5U] == 1)
	{
		motor[arm] = -127;
	}
}

void userDrive()
{
	// manage control modes with sustained press
	if(vexRT[Btn6D] == 1)
	{
		manualTwoStickDrive(forwardDirection);
	}
	else if (vexRT[Btn6U] == 1)
	{
		manualAccelerometerDrive(forwardDirection);
	}
	else
	{
		manualOneStickDrive(forwardDirection);
	}
}

// Data Input
// --------------------------------------------------

void updateSensorValues()
{
	// update sensor values
	distanceFrom = SensorValue[dgtl8];
}


// Autonomous mode
// --------------------------------------------------


// Main
// --------------------------------------------

void pre_auton()
{
}

task autonomous()
{

	// go forward
	for(int i = 0; i <= 127; i++)
	{
			motor[leftWheel] = i;
			motor[rightWheel] = i;
			wait1Msec(2);
	}

	wait1Msec(1000);

	// slow down
	for(int i = 127; i >= 0; i--)
	{
		motor[leftWheel] = i;
		motor[rightWheel] = i;
		wait1Msec(2);
	}

	wait1Msec(500);

	// spin
	for(int i = 0; i <= 127; i++)
	{
		motor[leftWheel] = i;
		wait1Msec(2);
	}
	motor[rightWheel] = 30;

	wait1Msec(10000);

	// stop spin
	for(int i = 127; i >= 0; i--)
	{
		motor[leftWheel] = i;
		wait1Msec(2);
	}

	motor[rightWheel] = 0;
}

task usercontrol()
{

	while(true)
	{
		// get user input
		userDrive();
		moveClaw();

		// toggle forward direction
		if(vexRT[Btn8D] == 1)
		{
			if(btn8_toggle == false)
			{
				forwardDirection *= -1;
			}
			btn8_toggle = true;
		}
		else
		{
			btn8_toggle = false;
		}

		updateSensorValues();
	}
}
